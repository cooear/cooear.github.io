<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[酷耳]]></title>
  <link href="http://cooear.com/atom.xml" rel="self"/>
  <link href="http://cooear.com/"/>
  <updated>2016-05-05T11:25:35+08:00</updated>
  <id>http://cooear.com/</id>
  <author>
    <name><![CDATA[cooear]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XX-Net接力GoAgent的工具]]></title>
    <link href="http://cooear.com/blog/2016/05/xx-net-jie-li-goagent/"/>
    <updated>2016-05-04T20:46:17+08:00</updated>
    <id>http://cooear.com/blog/2016/05/xx-net-jie-li-goagent</id>
    <content type="html"><![CDATA[<p>XX-Net是一个接力GoAgent的翻墙工具，XX-Net提供GAE proxy并且稳定、易用、快速，Web界面，人性化交互等。</p>

<p>XX-Net<a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md">下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[20个比较高级的Linux命令]]></title>
    <link href="http://cooear.com/blog/2016/05/20ge-bi-jiao-gao-ji-de-linuxming-ling/"/>
    <updated>2016-05-01T00:01:48+08:00</updated>
    <id>http://cooear.com/blog/2016/05/20ge-bi-jiao-gao-ji-de-linuxming-ling</id>
    <content type="html"><![CDATA[<p>也许你已经发现了前面关于<strong>Linux</strong>初级用户(刚接触<strong>Linux</strong>的用户)的20个命令非常有用。前面的那篇文章是为初学者准备，而这篇则是为有一定基础的中级用户准备。通过这篇文章你将了解到如何去自定义搜索，如何了解正在运行的进程并<strong>kill</strong>这些进程，另外就是了解<strong>Linux</strong>命令行的重要以及如何在类unix系统中编译<strong>C,C++,java</strong>程序。</p>

<ol>
<li><p><strong>Find命令</strong></p>

<p> 在指定的目录中从父目录开始逐级向下分层查询要查询的文件。</p>

<p> <!--more--></p>

<pre><code> root@belen:~# find -name *.sh 
 ./Desktop/load.sh 
 ./Desktop/test.sh 
 ./Desktop/shutdown.sh 
 ./Binary/firefox/run-mozilla.sh 
 ./Downloads/kdewebdev-3.5.8/quanta/scripts/externalpreview.sh 
 ./Downloads/kdewebdev-3.5.8/admin/doxygen.sh 
 ./Downloads/kdewebdev-3.5.8/admin/cvs.sh 
 ./Downloads/kdewebdev-3.5.8/admin/ltmain.sh 
 ./Downloads/wheezy-nv-install.sh 
</code></pre>

<p> <strong>注意</strong>："-name"是区分大小写的搜索。你可以使用"-iname"参数进行不区分大小写的搜索。(* 是一个通配符是搜索所有后缀名为'.sh'的文件)</p>

<pre><code> root@belen:~# find -iname *.SH ( find -iname *.Sh /  find -iname *.sH)
 ./Desktop/load.sh 
 ./Desktop/test.sh 
 ./Desktop/shutdown.sh 
 ./Binary/firefox/run-mozilla.sh 
 ./Downloads/kdewebdev-3.5.8/quanta/scripts/externalpreview.sh 
 ./Downloads/kdewebdev-3.5.8/admin/doxygen.sh 
 ./Downloads/kdewebdev-3.5.8/admin/cvs.sh 
 ./Downloads/kdewebdev-3.5.8/admin/ltmain.sh 
 ./Downloads/wheezy-nv-install.sh



 root@belen:~# find -name *.tar.gz 
 /var/www/modules/update/tests/aaa_update_test.tar.gz 
 ./var/cache/flashplugin-nonfree/install_flash_player_11_linux.i386.tar.gz 
 ./home/server/Downloads/drupal-7.22.tar.gz 
 ./home/server/Downloads/smtp-7.x-1.0.tar.gz 
 ./home/server/Downloads/noreqnewpass-7.x-1.2.tar.gz 
 ./usr/share/gettext/archive.git.tar.gz 
 ./usr/share/doc/apg/php.tar.gz 
 ./usr/share/doc/festival/examples/speech_pm_1.0.tar.gz 
 ./usr/share/doc/argyll/examples/spyder2.tar.gz 
 ./usr/share/usb_modeswitch/configPack.tar.gz        
</code></pre>

<p> <strong>注意</strong>：上面的命令是在root目录包括其下面所有子目录挂载的设备目录中搜索扩展名为"tar.gz"的文件。更多<strong>find</strong>相关命令，请查看。 <br/>
<br/></p></li>
<li><p><strong>grep命令</strong></p>

<p> &ldquo;grep"命令在指定的文件中逐行匹配要搜索的字符。如：在&rdquo;/etc/passwd"中搜索用户'belen'。</p>

<pre><code> root@belen:~# grep tecmint /etc/passwd 
 belen:x:1000:1000:Belen,,,:/home/belen:/bin/bash
</code></pre>

<p> 忽略字符大小写需要使用"-i"参数。</p>

<pre><code> root@belen:~# grep -i BELEN /etc/passwd 
 belen:x:1000:1000:Belen,,,:/home/belen:/bin/bash
</code></pre>

<p> 递归搜索使用参数"-r"，如：在指定目录中逐个目录搜索包含"127.0.0.1"。</p>

<pre><code> root@belen:~# grep -r "127.0.0.1" /etc/ 
 /etc/vlc/lua/http/.hosts:127.0.0.1
 /etc/speech-dispatcher/modules/ivona.conf:#IvonaServerHost "127.0.0.1"
 /etc/mysql/my.cnf:bind-address      = 127.0.0.1
 /etc/apache2/mods-available/status.conf:    Allow from 127.0.0.1 ::1
 /etc/apache2/mods-available/ldap.conf:    Allow from 127.0.0.1 ::1
 /etc/apache2/mods-available/info.conf:    Allow from 127.0.0.1 ::1
 /etc/apache2/mods-available/proxy_balancer.conf:#    Allow from 127.0.0.1 ::1
 /etc/security/access.conf:#+ : root : 127.0.0.1
 /etc/dhcp/dhclient.conf:#prepend domain-name-servers 127.0.0.1;
 /etc/dhcp/dhclient.conf:#  option domain-name-servers 127.0.0.1;
 /etc/init/network-interface.conf:   ifconfig lo 127.0.0.1 up || true
 /etc/java-6-openjdk/net.properties:# localhost &amp; 127.0.0.1).
 /etc/java-6-openjdk/net.properties:# http.nonProxyHosts=localhost|127.0.0.1
 /etc/java-6-openjdk/net.properties:# localhost &amp; 127.0.0.1).
 /etc/java-6-openjdk/net.properties:# ftp.nonProxyHosts=localhost|127.0.0.1
 /etc/hosts:127.0.0.1    localhost       
</code></pre>

<p> <strong>注意</strong>：你还可以在grep命令后使用一下参数。</p>

<p> <strong>-w</strong> 匹配单词(<strong>egrep -w &lsquo;word1 | word2&rsquo; /path/to/file</strong>)在指定文件中匹配word1或者word2这两个单词。 -c 计数(grep -c &lsquo;word&rsquo; /path/to/file)即在指定文件中出现'word'的次数 -color 着重色输出(<strong>grep -color server /etc/passwd</strong>)</p>

<p> <br/></p></li>
<li><p><strong>man命令</strong></p>

<p> &lsquo;man'是系统自带的手册帮助也。Man为所有命令可以使用的参数提供在线帮助文档。比如：</p>

<pre><code> root@belen:~# man man

         MAN(1)
         Manual pager utils
         MAN(1)

 NAME
        man - an interface to the on-line reference manuals

 SYNOPSIS
        man  [-C  file]  [-d]  [-D]  [--warnings[=warnings]]  [-R  encoding]  [-L  locale]  [-m  system[,...]]  [-M  path]  [-S list] [-e extension] [-i|-I]
        [--regex|--wildcard] [--names-only] [-a] [-u] [--no-subpages] [-P pager] [-r prompt] [-7] [-E encoding] [--no-hyphenation] [--no-justification]  [-p
        string] [-t] [-T[device]] [-H[browser]] [-X[dpi]] [-Z] [[section] page ...] ...
        man -k [apropos options] regexp ...
        man -K [-w|-W] [-S list] [-i|-I] [--regex] [section] term ...
        man -f [whatis options] page ...
        man -l [-C file] [-d] [-D] [--warnings[=warnings]] [-R encoding] [-L locale] [-P pager] [-r prompt] [-7] [-E encoding] [-p string] [-t] [-T[device]]
        [-H[browser]] [-X[dpi]] [-Z] file ...
        man -w|-W [-C file] [-d] [-D] page ...
        man -c [-C file] [-d] [-D] page ...
        man [-hV]
</code></pre>

<p> &ldquo;<strong>Man</strong>"自己的手册帮助页，再比如'man cat'和'man ls'。</p>

<p> <strong>注意</strong>：man 帮助页对于命令的学习使用非常有用。</p>

<p> <br/></p></li>
<li><p><strong>ps命令</strong></p>

<p> ps命令打印出正在运行的进程的唯一id和PID。</p>

<pre><code> root@belen:~# ps
 PID TTY          TIME CMD
 4170 pts/1    00:00:00 bash
 9628 pts/1    00:00:00 ps
</code></pre>

<p> 使用'-A'参数列出所有拥有Id和PID的进程。</p>

<pre><code> root@belen:~# ps -A

  PID TTY          TIME CMD
     1 ?        00:00:01 init
     2 ?        00:00:00 kthreadd
     3 ?        00:00:01 ksoftirqd/0
     5 ?        00:00:00 kworker/0:0H
     7 ?        00:00:00 kworker/u:0H
     8 ?        00:00:00 migration/0
     9 ?        00:00:00 rcu_bh
 ....
</code></pre>

<p> <strong>注意</strong>：当你想知道系统中有那些进程正在运行或者你需要PID去结束一个进程时这个命令是非常有用的。你可用把这个命令和'grep'结合使用可以精准输出有用的信息。</p>

<pre><code> root@belen:~# ps -A | grep -i ssh

 1500 ?        00:09:58 sshd
 4317 ?        00:00:00 sshd
</code></pre>

<p> <strong>注</strong>：上面的命令'<strong>ps</strong>&lsquo;是&rsquo;<strong>grep</strong>&lsquo;命令的管道用于展示出我们需要的信息。</p>

<p> <br/></p></li>
<li><p><strong>kill命令</strong></p>

<p> 从命令的名称你就会明白这个命令的用途。没错这个命令就是用于杀掉(kill)那些部相关的或者没有相应的进程的。这是一个非常有用的命令。你可又能已经习惯了Windows系统的频繁重启，因为Windows中的大部分进程是不能被杀的，即使杀掉了也需要系统重启才能生效;但这些在Linux中不会出现，在Linux中你可以杀死一个进程而不许要重启系统。</p>

<p> 你需要一个进程的<strong>&lsquo;pid&rsquo;(ps)</strong>去杀掉这个进程。
让我们展示如何使用"<strong>ps -A</strong>&ldquo;和&rdquo;<strong>grep</strong>&ldquo;命令查询我们想要结束的'apache2'进程，然后<strong>kill</strong>掉这个进程。</p>

<pre><code>  root@belen:~# ps -A | grep -i apache2
  1285 ?        00:00:00 apache2
</code></pre>

<p>  上面的例子找到了'apache2'进程的相关信息,&lsquo;apache2'进程的pid是'1285'。</p>

<pre><code>  root@belen:~# kill 1285 (to kill the process apache2)
</code></pre>

<p>  <strong>注意</strong>：每次打开或者重启系统每个进程的pid都是不同的，你可以使用'ps'命令查看当前的进程PID。</p>

<p>  另外一种kill进程的方式：</p>

<pre><code>  root@belen:~# pkill apache2
</code></pre>

<p>  <strong>注意</strong>：'kill'命令需要脚本或者进程的id，而'pkill'入上面的例子你可以指定进程的所属进程命。</p>

<p>  <br/></p></li>
<li><p><strong>whereis命令</strong></p>

<p> &ldquo;whereis"命令是用于定位二进制，源码和Manual Pages的位置命令。例如：</p>

<pre><code> root@belen:~# whereis ls 
 ls: /bin/ls /usr/share/man/man1/ls.1.gz

 root@belen:~# whereis kill
 kill: /bin/kill /usr/share/man/man2/kill.2.gz /usr/share/man/man1/kill.1.gz
</code></pre>

<p> <strong>注意</strong>：这个命令对于我们想编译二进制文件时确定位置是非常有用的。</p>

<p> <br/></p></li>
<li><p><strong>service命令</strong></p>

<p> &ldquo;<strong>service</strong>"命令控制者服务的打开(Starting)，停止(Stopping),重启(Restarting)。这个命令可使服务在系统不重启的情况下start,restart或者stop。</p>

<p> 在Ubuntu中启动apache2服务</p>

<pre><code> root@belen:~# service apache2 start

 * Starting web server apache2
 apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1 for ServerName
 httpd (pid 1285) already running
 [ OK ]
</code></pre>

<p> 在Ubuntu中重启apache2服务</p>

<pre><code> root@belen:~# service apache2 restart

 * Restarting web server apache2                                                                                                                          
 apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1 for ServerName
 ... waiting .apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1 for ServerName  [ OK ] 
</code></pre>

<p> 在Ubuntu中停止apache2服务</p>

<pre><code> root@belen:~# service apache2 stop

 * Stopping web server apache2 
 apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1 for ServerName
 ... waiting     
</code></pre>

<p> <strong>注意</strong>：所有的进程脚本都存在于'<strong>/etc/init.d</strong>&lsquo;中，不同系统路径可能有差异;即，虽然你运行的是"service apache2 start"但实际"<strong>/etc/init.d/apache2 start</strong>&ldquo;要执行。</p>

<p> <br/></p></li>
<li><p><strong>alias命令</strong></p>

<p> &ldquo;<strong>alias</strong>"是一个让你为一个较长的命令取别名的shell命令。
我现在使用别名'l'代替命令'ls -l'命令的5个字符（包括空格）。</p>

<pre><code>  root@belen:~# alias l='ls -l'
</code></pre>

<p>  检验'<strong>l</strong>&lsquo;命令是否正常执行。</p>

<pre><code>  root@belen:~# l

  total 36 
  drwxr-xr-x 3 tecmint tecmint 4096 May 10 11:14 Binary 
  drwxr-xr-x 3 tecmint tecmint 4096 May 21 11:21 Desktop 
  drwxr-xr-x 2 tecmint tecmint 4096 May 21 15:23 Documents 
  drwxr-xr-x 8 tecmint tecmint 4096 May 20 14:56 Downloads 
  drwxr-xr-x 2 tecmint tecmint 4096 May  7 16:58 Music 
  drwxr-xr-x 2 tecmint tecmint 4096 May 20 16:17 Pictures 
  drwxr-xr-x 2 tecmint tecmint 4096 May  7 16:58 Public 
  drwxr-xr-x 2 tecmint tecmint 4096 May  7 16:58 Templates 
  drwxr-xr-x 2 tecmint tecmint 4096 May  7 16:58 Videos
</code></pre>

<p>  删除命令别名'l'使用'<strong>unalias</strong>&lsquo;。</p>

<pre><code>  root@belen:~# unalias l
</code></pre>

<p>  检验'l'命令是否正常执行。</p>

<pre><code>  root@belen:~# l
  bash: l: command not found
</code></pre>

<p>  你可以使用别名命令找些乐子，也可以为某些重要的命令取些只有你知道的别名。</p>

<pre><code>  alias cd='ls -l' (set alias of ls -l to cd)
  alias su='pwd' (set alias of pwd to su)
  ....
  (You can create your own)
  ....    
</code></pre>

<p>  现在如果有人在你的计算机上吃用'cd'命令，那么Ta将为打印出来的列表感到困惑;当使用'su'命令而看到当前目录时依然如此。当然你可以在不用时使用'<strong>unalias</strong>&lsquo;删除这些别名命令。</p>

<p>  <br/></p></li>
<li><p><strong>df命令</strong></p>

<p> &ldquo;<strong>df</strong>"命令报告系统硬盘使用情况。改命令对于管理员或用户掌控硬盘使用情况非常的有用。</p>

<pre><code> root@belen:~# df

 Filesystem     1K-blocks    Used Available Use% Mounted on
 /dev/sda1       47929224 7811908  37675948  18% /
 none                   4       0         4   0% /sys/fs/cgroup
 udev             1005916       4   1005912   1% /dev
 tmpfs             202824     816    202008   1% /run
 none                5120       0      5120   0% /run/lock
 none             1014120     628   1013492   1% /run/shm
 none              102400      44    102356   1% /run/user
 /dev/sda5         184307   79852     94727  46% /boot
 /dev/sda7       95989516   61104  91045676   1% /data
 /dev/sda8       91953192   57032  87218528   1% /personal
</code></pre>

<p> 更多关于"df"的命令，请查看。</p>

<p> <br/></p></li>
<li><p><strong>du命令</strong></p>

<p>估计文件空间使用情况。递归展示文件夹中文件使用磁盘的简要信息。</p>

<pre><code>root@belen:~# du

8       ./Daily Pics/wp-polls/images/default_gradient
8       ./Daily Pics/wp-polls/images/default
32      ./Daily Pics/wp-polls/images
8       ./Daily Pics/wp-polls/tinymce/plugins/polls/langs
8       ./Daily Pics/wp-polls/tinymce/plugins/polls/img
28      ./Daily Pics/wp-polls/tinymce/plugins/polls
32      ./Daily Pics/wp-polls/tinymce/plugins
36      ./Daily Pics/wp-polls/tinymce
580     ./Daily Pics/wp-polls
1456    ./Daily Pics
36      ./Plugins/wordpress-author-box
16180   ./Plugins
12      ./May Articles 2013/Xtreme Download Manager
4632    ./May Articles 2013/XCache
</code></pre>

<p><strong>注意</strong>："df"用于报告文件系统的空间使用情况，而"du"主要报告目录内容。更多'du'命令，请查看。</p>

<p><br/></p></li>
<li><p><strong>rm命令</strong></p>

<p>&ldquo;rm"命令用于删除文件或目录。</p>

<p>删除目录</p>

<pre><code>root@belen:~# rm 
PassportApplicationForm_Main_English_V1.0
rm: cannot remove 
`PassportApplicationForm_Main_English_V1.0': Is a directory
</code></pre>

<p>仅仅使用"rm"命令不能删除目录，你需要在"rm"命令后追加"-rf"参数。</p>

<pre><code>root@belen:~# rm -rf
PassportApplicationForm_Main_English_V1.0   
</code></pre>

<p><strong>警告</strong>：如果你使用"<strong>rm -rf</strong>&ldquo;误删除了一个目录那么将是灾难性的。一旦你使用"rm -rf"删除一个目录那么将永久性的删除目录下面的所有文件。请谨慎操作。</p>

<p><br/></p></li>
<li><p><strong>echo命令</strong></p>

<p>&ldquo;<strong>echo</strong>"顾名思义是纯文本输出命令。它不会操作shell命令，shell也不会读取输出的命令。然而，在一个交互性的脚本中，可以输出相关信息到命令终端。这在互动脚本中是一个非常有用的命令。</p>

<pre><code>root@belen:~# echo "cooear.com is a very good website" 
cooear.com is a very good website
</code></pre>

<p>创建一个简单的交互文本</p>

<p>1.在桌面上创建一个interactive_shell.sh。（注意.sh的扩展是必须的）</p>

<p>2.复制下面的内容到这个脚本中。</p>

<pre><code>#!/bin/bash 
echo "Please enter your name:" 
read name
echo "Welcome to Linux $name"
</code></pre>

<p>接下来，给这个脚本可执行权限并运行。</p>

<pre><code>root@belen:~# chmod 777 interactive_shell.sh

root@belen:~# ./interactive_shell.sh
Please enter your name:
Belen
Welcome to Linux Belen  
</code></pre>

<p><strong>注意</strong>：'<strong>#!/bin/bash</strong>&lsquo;告诉shell这是一个脚本程序在shell脚本头部写上这行代码是非常必要的，'read'读取输入的值。</p>

<p><br/></p></li>
<li><p><strong>passwd命令</strong></p>

<p>&ldquo;<strong>passwd</strong>"是在命令终端修改密码非常有用的命令。很明显为了安全起见你必须知道当前密码。</p>

<pre><code>root@belen:~# passwd 

Changing password for tecmint. 
(current) UNIX password: ******** 
Enter new UNIX password: ********
Retype new UNIX password: ********
Password unchanged   [Here was passowrd remians unchanged, i.e., new password=old password]
Enter new UNIX password: #####
Retype new UNIX password:#####
</code></pre>

<p><br/></p></li>
<li><p><strong>lpr命令</strong></p>

<p>&ldquo;<strong>lpr</strong>"将档案或是由标准输入送进来的资料送到打印机贮列之中，打印机管理程序 lpd 会在稍后将这个档案送给适当的程序或装置处理。lpr 可以用来将料资送给本地或是远端的主机来处理。</p>

<pre><code>root@belen:~# lpr -P deskjet-4620-series 1-final.pdf
</code></pre>

<p><strong>注意</strong>："<strong>lpq</strong>&ldquo;命令让你查看打印机的状态(是否可用),以及正在等待中的打印任务。</p>

<p><br/></p></li>
<li><p><strong>cmp命令</strong></p>

<p>&ldquo;<strong>cmp</strong>"比较两个文件的差异。默认情况下如果两个文件相同那么返回0;如果有差异则标示出第一个不同之处的字符和列数编号。</p>

<p>file1.txt</p>

<pre><code>root@belen:~# cat file1.txt
Hi My name is Tecmint
</code></pre>

<p>file2.txt</p>

<pre><code>root@belen:~# cat file2.txt
Hi My name is tecmint [dot] com
</code></pre>

<p>现在比较两个文件的输出差异：</p>

<pre><code>root@belen:~# cmp file1.txt file2.txt 
file1.txt file2.txt differ: byte 15, line 1
</code></pre>

<p><br/></p></li>
<li><p><strong>wget命令</strong></p>

<p>&ldquo;<strong>wget</strong>"是一个免费的非交互是的下载工具(支持后台下载)，可用从web页面下载文件，支持HTTP,HTTPS,FTP协议和HTTP代理。</p>

<p>使用wget下载ffmpeg</p>

<pre><code>root@belen:~# wget http://downloads.sourceforge.net/project/ffmpeg-php/ffmpeg-php/0.6.0/ffmpeg-php-0.6.0.tbz2

--2013-05-22 18:54:52--  http://downloads.sourceforge.net/project/ffmpeg-php/ffmpeg-php/0.6.0/ffmpeg-php-0.6.0.tbz2
Resolving downloads.sourceforge.net (downloads.sourceforge.net)... 216.34.181.59
Connecting to downloads.sourceforge.net (downloads.sourceforge.net)|216.34.181.59|:80... connected.
HTTP request sent, awaiting response... 302 Found
Location: http://kaz.dl.sourceforge.net/project/ffmpeg-php/ffmpeg-php/0.6.0/ffmpeg-php-0.6.0.tbz2 [following]
--2013-05-22 18:54:54--  http://kaz.dl.sourceforge.net/project/ffmpeg-php/ffmpeg-php/0.6.0/ffmpeg-php-0.6.0.tbz2
Resolving kaz.dl.sourceforge.net (kaz.dl.sourceforge.net)... 92.46.53.163
Connecting to kaz.dl.sourceforge.net (kaz.dl.sourceforge.net)|92.46.53.163|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 275557 (269K) [application/octet-stream]
Saving to: ‘ffmpeg-php-0.6.0.tbz2’

100%[===========================================================================&gt;] 2,75,557    67.8KB/s   in 4.0s   

2013-05-22 18:55:00 (67.8 KB/s) - ‘ffmpeg-php-0.6.0.tbz2’ saved [275557/275557]
</code></pre>

<p><br/></p></li>
<li><p><strong>mount命令</strong></p>

<p>&ldquo;<strong>mount</strong>"用于挂载那些在Linux系统中不能自动挂载的文件系统。使用该命令需要root权限。</p>

<p>在你插入你的文件系统后，首先运行"lsblk"查看你的设备名称并记下他们的名称。</p>

<pre><code>root@belen:~# lsblk 

NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT 
sda      8:0    0 931.5G  0 disk 
├─sda1   8:1    0 923.6G  0 part / 
├─sda2   8:2    0     1K  0 part 
└─sda5   8:5    0   7.9G  0 part [SWAP] 
sr0     11:0    1  1024M  0 rom  
sdb      8:16   1   3.7G  0 disk 
└─sdb1   8:17   1   3.7G  0 part
</code></pre>

<p>从上面的代码可以清楚的看出我插入了一个4G的设备，因此'sdb1'是我要挂载的文件系统。切换到root用户将该设备挂载到常用的挂载目录'/dev'。</p>

<pre><code>root@belen:~# su
Password:   
</code></pre>

<p><p></p>
    root@belen:~# cd /dev</p>

<p>创建一个和挂载设备相关的目录名（便于以后查看）。</p>

<pre><code>root@belen:~# mkdir usb
</code></pre>

<p>现在将文件系统'sdb1'挂载到目录'usb'。</p>

<pre><code>root@belen:~# mount /dev/sdb1 /dev/usb
</code></pre>

<p>现在你可以从终端或者X-windows系统通过/dev/usb目录访问被挂载的目录了。</p>

<p><br/></p></li>
<li><p><strong>gcc命令</strong></p>

<p>&ldquo;<strong>gcc</strong>"用于在Linux系统中编译'C'语言的程序。一个简单的'C'语言程序我们将它保存在桌面上命名为Hello.c(切记'.c'的扩展是必须的)。</p>

<pre><code>#include 
int main()
{
  printf("Hello world\n");
  return 0;
}
</code></pre>

<p>编译c程序</p>

<pre><code>root@belen:~# gcc Hello.c
</code></pre>

<p>运行c程序</p>

<pre><code>root@belen:~# ./a.out 
Hello world 
</code></pre>

<p><strong>注意</strong>：上面的c程序在编译时会自动生成一个新文件"a.out",而你每次编译c程序都会生成一个同名的'a.out'覆盖前面的文件，因此在编译时指定一个输出文件是十分必要的。</p>

<p>编译输出到指定文件</p>

<pre><code>root@belen:~# gcc -o Hello Hello.c
</code></pre>

<p>这里'-o'让编译后生成'Hello'而非'a.out'文件。运行：</p>

<pre><code>root@belen:~# ./Hello 
Hello world
</code></pre>

<p><br/></p></li>
<li><p><strong>g++命令</strong></p>

<p>&ldquo;<strong>g++</strong>"用于编译"C++"第一个面向对象的编程语言。创建一个简单的c++程序，并在桌面上保存为Add.cpp(切记'.cpp'扩展是必须的)。</p>

<pre><code>#include 

using namespace std;

int main() 
    {
          int a;
          int b;
          cout&lt;&lt;"Enter first number:\n";
          cin &gt;&gt; a;
          cout &lt;&lt;"Enter the second number:\n";
          cin&gt;&gt; b;
          cin.ignore();
          int result = a + b;
          cout&lt;&lt;"Result is"&lt;&lt;"  "&lt;
     }     
</code></pre>

<p>编译：</p>

<pre><code>root@belen:~# g++ Add.cpp
</code></pre>

<p>运行：</p>

<pre><code>root@belen:~# ./a.out

Enter first number: 
...
...
</code></pre>

<p><strong>注意</strong>：上面的c++程序在编译时会自动生成一个新文件"a.out",而你每次编译c++程序都会生成一个同名的'a.out'覆盖前面的文件，因此在编译时指定一个输出文件是十分必要的。</p>

<p>编译到指定文件：</p>

<pre><code>root@belen:~# g++ -o Add Add.cpp
</code></pre>

<p>运行：</p>

<pre><code>root@belen:~# ./Add 

Enter first number: 
...
...     
</code></pre>

<p><br/></p></li>
<li><p><strong>java命令</strong></p>

<p>Java是一个世界上广泛使用的编程语言而且快速,安全,可靠。当今的很多web服务都是基于java开发的。</p>

<p>创建一个名字为belen.java的java程序（切记'.java'扩展是必须的）。</p>

<pre><code>class belen {
  public static void main(String[] arguments) {
    System.out.println("Tecmint ");
  }
}
</code></pre>

<p>使用javac编译：</p>

<pre><code>root@belen:~# javac belen.java
</code></pre>

<p>运行：</p>

<pre><code>root@belen:~# java belen
</code></pre>

<p><strong>注意</strong>：几乎所欲的分支都包含路gcc编译器，大部分是g++编译器，当然有些是没有的。你可以使用apt或者yum命令安装某些必须的软件包。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[国外DNS服务器列表]]></title>
    <link href="http://cooear.com/blog/2016/04/guo-wai-dnsfu-wu-qi-lie-biao/"/>
    <updated>2016-04-29T18:13:51+08:00</updated>
    <id>http://cooear.com/blog/2016/04/guo-wai-dnsfu-wu-qi-lie-biao</id>
    <content type="html"><![CDATA[<h3>对付DNS劫持，就要国外DNS服务器：</h3>

<pre><code>8.8.8.8    
8.8.4.4

##支持非标准端口(443、5353)
208.67.222.222    
208.67.220.220

209.244.0.3    
209.244.0.4

156.154.70.1
156.154.71.1

4.2.2.1    
4.2.2.2

208.76.50.50
208.76.51.51

198.153.192.40
198.153.194.40

198.153.192.50
198.153.194.50

198.153.192.60    
198.153.194.60

8.26.56.26
8.20.247.20

184.169.143.224
184.169.161.155

67.138.54.100
207.225.209.66
</code></pre>

<!--more-->


<p></p>

<h3>配置方法：</h3>

<p>控制面板——》网络和Internet——》网络和共享中心——》更改适配器设置——》找到本地连接（就是正在用的那个网络连接）——》右键属性——》Internet协议版本4——》双击打开之后把“自动获取DNS服务器地址”改为“使用下面的DNS服务器地址”并填上地址（从上面那堆里任选一个）。</p>

<h3>刷新DNS缓存：</h3>

<p>WINDOWS：win+r之后输入cmd回车，再输入并点击回车键</p>

<pre><code>    ipconfig/flushdns
</code></pre>

<p>OS X 10.10: 在［应用程序］［实用工具］［终端］运行命令</p>

<pre><code>    sudo discoveryutil udnsflushcaches
</code></pre>

<p>OS X 10.9: 在［应用程序］［实用工具］［终端］运行命令</p>

<pre><code>    dscacheutil -flushcache; sudo killall -HUP mDNSResponder
</code></pre>

<p>OS X 10.7 ~ 10.8: 在［应用程序］［实用工具］［终端］运行命令</p>

<pre><code>    sudo killall -HUP mDNSResponder
</code></pre>

<p>Linux: 在［终端］运行命令</p>

<pre><code>    /etc/rc.d/init.d/nscd restart       
</code></pre>

<p>Android、iOS: 重新启动设备</p>

<p><strong>注意</strong>：由于地域的不同，相同的DNS解析速度差别可能会很大；Google尽管在服务器上有着无人不知的优势，但在你所处的地域速度可能不是最理想的。所以请根据自己的情况选择适合自己的DNS服务,DNS速度测试工具<a href="http://g1c1i0.cooear.com/images/uploads/2015/03/DNSBench.rar">DNSBench下载</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenWrt使用ShadowSocks透明代理智能翻墙上网]]></title>
    <link href="http://cooear.com/blog/2015/02/openwrtshi-yong-shadowsockstou-ming-dai-li-zhi-neng-fan-qiang-shang-wang/"/>
    <updated>2015-02-14T10:00:09+08:00</updated>
    <id>http://cooear.com/blog/2015/02/openwrtshi-yong-shadowsockstou-ming-dai-li-zhi-neng-fan-qiang-shang-wang</id>
    <content type="html"><![CDATA[<p>　　<font color=red >本教程前提是需要有一个ShadowSocks账号或安装ShadowSocks服务的VPS（墙外的）</font>。</p>

<h3>一、安装<strong>OpenWrt</strong>并配置上网</h3>

<ol>
<li><p>telnet 192.168.1.1 至Openwrt并修改root密码</p>

<pre><code> telnet 192.168.1.1  
</code></pre></li>
<li><p>配置上网参数</p>

<pre><code> uci set network.wan.proto=pppoe
 uci set network.wan.username=name
 uci set network.wan.password=123456
 uci commit network ifup wan
</code></pre></li>
<li><p>安装luci界面，并配置开机启动</p>

<pre><code> opkg update
 opkg install luci
 /etc/init.d/uhttpd start
 /etc/init.d/uhttpd enable 
</code></pre></li>
<li><p>修改luci界面端口号</p>

<pre><code> vim /etc/config/uhttpd
</code></pre>

<p> <!--more--></p></li>
<li><p>修改ssh默认的22端口号</p>

<pre><code> vim /etc/config/dropbear
</code></pre></li>
<li><p>自定义DNS</p>

<p> <em>a.</em> 创建 /etc/config/sec_resolv.conf</p>

<pre><code> vim /etc/config/sec_resolv.conf
 nameserver 8.8.8.8
 nameserver 8.8.4.4
 nameserver 208.67.222.222
</code></pre>

<p> <em>b.</em>  编辑 /etc/config/dhcp</p>

<p> 找到 option resolvfile 选项，替换/tmp/resolv.conf.auto为/etc/config/sec_resolv.conf.</p></li>
</ol>


<h3>二、软件包安装</h3>

<p>执行命令：</p>

<pre><code>opkg update
</code></pre>

<p>shadowsocks-libev<a href="http://sourceforge.net/projects/openwrt-dist/files/shadowsocks-libev/">下载</a>：</p>

<p>必须包安装：</p>

<p>olarssl版本的shadowsocks（polarssl体积更小）：</p>

<pre><code>opkg install iptables-mod-nat-extra ipset libpolarssl
</code></pre>

<p>普通版本（openssl）的shadowsocks，那么(openssl兼容性更好)：</p>

<pre><code>opkg install iptables-mod-nat-extra ipset libopenssl
</code></pre>

<p>卸载dnsmasq并安装dnsmasq-full以及相应的扩展包(dnsmasq没有ipset功能)</p>

<pre><code>opkg remove dnsmasq &amp;&amp; opkg install dnsmasq-full
cd /tmp
opkg install shadowsocks-libev_x.x.x-x_ar71xx.ipk
</code></pre>

<h3>三、配置</h3>

<ol>
<li><p>配置/etc/shadowsocks.json</p>

<pre><code> {
     "server": "X.X.X.X",
     "server_port": "443",
     "password": "password",
     "local_port": "1080",
     "method": "aes-256-cfb"
 }
</code></pre></li>
<li><p>修改/etc/init.d/shadowsocks ，其实就是把Client Mode注释掉再把Proxy Mode的注释去掉</p>

<pre><code> #!/bin/sh /etc/rc.common

 START=95

 SERVICE_USE_PID=1
 SERVICE_WRITE_PID=1
 SERVICE_DAEMONIZE=1
 SERVICE_PID_FILE=/var/run/shadowsocks.pid
 CONFIG=/etc/shadowsocks.json

 start() {
     # Client Mode
     #service_start /usr/bin/ss-local -c $CONFIG -f $SERVICE_PID_FILE
     # Proxy Mode
     service_start /usr/bin/ss-redir -c $CONFIG -f $SERVICE_PID_FILE
 }

 stop() {
     # Client Mode
     #service_stop /usr/bin/ss-local
     # Proxy Mode
     service_stop /usr/bin/ss-redir
 }
</code></pre></li>
<li><p>启动shadowsocks，并设置开机运行：</p>

<pre><code> /etc/init.d/shadowsocks enable
 /etc/init.d/shadowsocks start
</code></pre></li>
</ol>


<h3>四、配置dnsmasq和ipset</h3>

<ol>
<li><p>将iptables规则加入防火墙中（添加至/etc/rc.local可开机启动）</p>

<pre><code> ipset -N gfwlist iphash
 iptables -t nat -A PREROUTING -p tcp -m set –match-set gfwlist dst -j REDIRECT –to-port 1080
 iptables -t nat -A OUTPUT -p tcp -m set –match-set gfwlist dst -j REDIRECT –to-port 1080
</code></pre></li>
<li><p>修改/etc/dnsmasq.conf，在最后加入 conf-dir=/etc/dnsmasq.d ，新建并进入目录/etc/dnsmasq.d，并将my_dnsmasq.conf放入该目录。</p>

<p> my_dnsmasq.conf具体格式如下：</p>

<pre><code> #使用不受污染干扰的DNS解析该域名 可以将此IP改为自己使用的DNS服务器
 server=/google.com/208.67.222.222#443
 #将解析出来的IP保存到名为gfwlist的ipset表中
 ipset=/google.com/gfwlist
</code></pre></li>
</ol>


<h3>五、ss-tunnel转发UDP的DNS的请求</h3>

<pre><code>#!/bin/sh /etc/rc.common

START=95

SERVICE_USE_PID=1
SERVICE_WRITE_PID=1
SERVICE_DAEMONIZE=1
SERVICE_PID_FILE=/var/run/shadowsocks.pid
CONFIG=/etc/shadowsocks.json
DNS=8.8.8.8:53
TUNNEL_PORT=5353

start() {
    # Client Mode
    #service_start /usr/bin/ss-local -c $CONFIG -f $SERVICE_PID_FILE
    # Proxy Mode
    service_start /usr/bin/ss-redir -c $CONFIG -f $SERVICE_PID_FILE
    # Tunnel
    service_start /usr/bin/ss-tunnel -c $CONFIG -u -l $TUNNEL_PORT -L $DNS
}

stop() {
    # Client Mode
    #service_stop /usr/bin/ss-local
    # Proxy Mode
    service_stop /usr/bin/ss-redir
    # Tunnel
    service_stop /usr/bin/ss-tunnel
}
</code></pre>

<p><strong>注</strong>：至此路由器已经my_dnsmasq.conf里面的域名已经会自动使用ss代理翻墙</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lantern(灯笼)安装和使用教程]]></title>
    <link href="http://cooear.com/blog/2014/08/lantern-deng-long-an-zhuang-he-shi-yong-jiao-cheng/"/>
    <updated>2014-08-09T12:29:42+08:00</updated>
    <id>http://cooear.com/blog/2014/08/lantern-deng-long-an-zhuang-he-shi-yong-jiao-cheng</id>
    <content type="html"><![CDATA[<p>　　<a href="https://www.getlantern.org/">Lantern</a> 的主要目的是访问：得到快速可靠的连接，拥抱广阔的因特网，自由浏览。绝大多数翻墙软件需要服务器。在Lantern系统中，每台机器都可以作为服务器，从而比其他工 具提供更多的容量。通过运行Lantern，每个在非封锁区的电脑，都可以变成封锁区用户的代理，使他们可以访问被封锁的网站，诸如 Twitter，Facebook，Youtube，等等。Lantern的核心是信任网络，使用者邀请他们的朋友来建立Lantern网络（使用最新版的Lantern当前为1.4无需邀请直接使用）。通过只邀请他们信任的人分享因特网连接，大家共同努力，来增加网络反抗审查者的封锁的能力。你的Lantern朋友越多，因特网的速度和可靠性就越高。工作原理如下图：</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2014/08/50b24994.vis.gif" title="Lantern 工作原理" alt="Lantern 工作原理" /></p>

<!--more-->


<h2>安装教程</h2>

<h3>1、首先你必须确定你已经安装好谷歌的Chrome浏览器，否则<strong>Lantern</strong>无法启动.</h3>

<h3>2、下载你系统对应的客户端程序，安装<strong>Lantern</strong>.</h3>

<p><a href="http://pan.baidu.com/s/1jG412Fs">Windows</a> &nbsp; &nbsp; &nbsp; &nbsp; <a href="http://pan.baidu.com/s/1hq5R2uC">Mac</a>&nbsp; &nbsp; &nbsp; &nbsp; <a href="http://pan.baidu.com/s/1i3iORzR">Linux</a></p>

<p>如果遇到安装错误、安装不了，请挂代理安装，因为需要连接到亚马逊服务器下载主程序和java程序。Lantern必须要在Java环境下运行，否则会出问题。</p>

<p><strong>2.1、</strong>完成后会弹出Lantern(灯笼)的介面面板，最新为Lantern1.4.3,如图：</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2014/08/20131123054656thw4v.jpeg" title="Lantern 安装完成" alt="Lantern 安装完成" /></p>

<h3>3、帐号设置和连接网络.</h3>

<p><strong>3.1</strong> 使用gmail账号登入，如图：</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2014/08/201311230551378ozua.jpeg" title="Lantern 登陆" alt="Lantern 登陆" /></p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2014/08/20131123055143brtwp.jpeg" title="Lantern 登陆" alt="Lantern 登陆" /></p>

<p><strong>3.2</strong> 已成功和Lantern连接</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2014/08/201311230559344ixqv.jpeg" title="Lantern 登陆成功" alt="Lantern 登陆成功" /></p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2014/08/1.png" title="Lantern 登陆成功" alt="Lantern 登陆成功" /></p>

<p><strong>3.2.1</strong> 接入后如果发现一直停留在Communicating with Google Talk severs…界面，如下图：</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2014/08/talk.png" title="Lantern 登陆问题" alt="Lantern 问题" /></p>

<p> 问题：很明显，Lantern正在向 Google Talk服务器发送数据请求，但是在天朝google服务器群很多都是被屏蔽的，造成了 Lantern与Google Talk通话的阻隔</p>

<p> 解决：挂上全局的vpn（本人使用的是<a href="http://t.cn/RPZLMcB">VPN</a>的全局代理，试用一天VIP），然后重新运行Lantern，就可以完成google talk的连接了.</p>

<p> <strong>3.3</strong> 添加自动代理网站，如下图</p>

<p> <img src="http://g1c1i0.cooear.com/images/uploads/2014/08/3.2.1.jpeg" title="Lantern 代理设置" alt="Lantern 代理设置" /></p>

<p> <img src="http://g1c1i0.cooear.com/images/uploads/2014/08/2.png" title="Lantern 代理设置" alt="Lantern 代理设置" /></p>

<p> <strong>注意</strong>：在输入框中添加需要代理的网站地址，每个域名一行。</p>

<p> <strong> 4、</strong> 浏览器代理设置(以chrome为例)</p>

<p>　　装有switchysharp扩展的话，可以直接选择 【使用系统代理设置】；可以暂时停用switchysharp还可以在switchysharp【选项】【新建情景模式】，选择【自动配置】，在Url处填入你自己在<strong>Lantern</strong>获得pac文地址,切换到<strong>Lantern</strong>模式。如图：</p>

<p> <img src="http://g1c1i0.cooear.com/images/uploads/2014/08/3.png" title="Lantern 全局代理设置" alt="Lantern 全局代理设置" /></p>

<p> <img src="http://g1c1i0.cooear.com/images/uploads/2014/08/4.png" title="Lantern 的Chrome switchysharp设置" alt="Lantern 的Chrome switchysharp设置" /></p>

<p> <strong>5. Lantern</strong>设置成功，顺利浏览<strong>Youtube</strong>，如图：</p>

<p> <img src="http://g1c1i0.cooear.com/images/uploads/2014/08/66.png" title="Lantern 顺利翻墙" alt="Lantern 顺利翻墙" /></p>

<p> <br />
 <a href="http://cooear.com/blog/2014/05/goagent-switchysharp-tu-wen-jiao-cheng/">Goagent翻墙云梯</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwitchyOmega Chrome浏览器安装配置]]></title>
    <link href="http://cooear.com/blog/2014/05/switchyomega-configuration/"/>
    <updated>2014-05-05T10:49:58+08:00</updated>
    <id>http://cooear.com/blog/2014/05/switchyomega-configuration</id>
    <content type="html"><![CDATA[<h3>一、安装SwitchyOmega</h3>

<p>首先你需要安装 SwitchyOmega。<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif/?hl=zh">SwitchyOmega</a>可以在谷歌应用商店安装。</p>

<ul>
<li>如果因为网络问题安装失败，您也可以直接<a href="https://github.com/FelisCatus/SwitchyOmega/releases">在 Github 上下载最新版安装包</a>，然后按照下载页面上的说明手动安装。</li>
</ul>


<p>安装完毕后应该会自动打开选项页面，之后按以下说明操作即可。</p>

<h3>二、导入备份</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2016/05/14624164651.png" title="SwitchyOmega 安装" alt="SwitchyOmega 安装" /></p>

<!--more-->


<p>这里有一段介绍性的教程。如果想了解SwitchyOmega的不妨跟着教程走一遍。如果急着设置好的话，还是点跳过吧  。（阅览教程与否不影响接下来的步骤。）</p>

<p>按照下图，在导入导出页面点击“从备份文件恢复”。那么问题就来了，已经配置好的设置备份文件哪家强？SwitchyOmega项目组找FelisCatus！<a href="https://raw.githubusercontent.com/wiki/FelisCatus/SwitchyOmega/GFWList.bak">我这里有提供备份文件，大家可以自己下载使用</a>。假如打开来是个网页怎么办？右键另存为呗。此外如果曾经在SwitchySharp里配置过了，直接用SwitchySharp导出的备份文件也行的，不过要记得按照此页面最下方的说明，更改一下规则列表的网址</p>

<p>图中第三步会打开一个选择文件的对话框，这时候选择刚下载好的备份文件就行了。</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2016/05/14624164652.png" title="SwitchyOmega 导入/导出" alt="SwitchyOmega 导入/导出" /></p>

<h3>三、设置代理服务器</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2016/05/14624164653.png" title="SwitchyOmega 配置" alt="SwitchyOmega 配置" /></p>

<p>这部分比较简单，在“GFWed”情景模式设置好代理协议和端口就好了。再一次说明，请仔细阅读您所使用的代理软件说明书，尤其是不要填错了代理协议（常见的有HTTP或SOCKS），因为那个填错了有一大堆问题，程序还不会提示你填错了。</p>

<p>虽然我已经说过很多次了， <strong>但如果你还没有代理服务器，那你要 SwitchyOmega 干嘛呢？</strong>你需要去弄一个代理服务器/代理软件，然后先把代理运行起来再说。什么？哪里有免费的代理服务器？这和我又有什么关系呢？ SwitchyOmega 的作用只是告诉 Chrome 应该使用什么代理，配置哪些网址用哪些代理而已。 SwitchyOmega 不是翻墙软件，也没有义务提供免费的代理服务器或是帮你翻墙。</p>

<h3>四、更新规则列表</h3>

<p>GFWList 项目是一个经常更新的项目，提供的规则列表也是需要定期下载更新的。还好 SwitchyOmega 项目有提供自动下载功能，可以应对变化迅速的网络环境。不过，既然马上就要用来上网，那自然是要<strong>手动进行首次下载的</strong>，对不对？</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2016/05/14624164654.png" title="SwitchyOmega 更新规则列表" alt="SwitchyOmega 更新规则列表" /></p>

<p><strong>记得先在菜单里选自动切换模式</strong>。 用直接连接或系统模式有可能会下载失败。为什么呢？因为规则列表网址本身也有可能需要代理才能访问。</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2016/05/14624164655.png" title="SwitchyOmega 更新规则列表" alt="SwitchyOmega 更新规则列表" /></p>

<p>这还有什么好说的，在自动切换设置底部点击那个蓝色的“立即更新情景模式”按钮就是了。完全照着图片上的步骤点过去就是了，不需要多费功夫。当然有人会注意到自动切换又弹出一段教程。为什么呢？因为自动切换算是一个比较复杂的概念，今后的手动配置也需要用到自动切换。再一次的，这里是可以跳过教程的。想看看教程我也不反对，加深理解嘛。只是之后别忘记点那个“立即更新情景模式”按钮就好。</p>

<p>如果成功了，大概会像是图中这样：</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2016/05/14624164656.png" title="SwitchyOmega 情景模式配置" alt="SwitchyOmega 情景模式配置" /></p>

<p>（注： GFWList 规则列表网址已经变更，见此页面最下方说明。截图中仍然是旧网址，但除此之外操作步骤相同，并没有其他错误。）</p>

<p>但如果显示更新失败呢？图上很多字，我也不复述了。但我还是要再罗嗦一句，<strong>大部分出现“更新失败”提示的用户，都是因为代理服务器设置不正确。少部分呢？是因为其实没有代理服务器</strong>，只是盲目按照上面的图片走了个没有意义的流程。</p>

<p>但你不访问网页试试看，怎么知道代理服务器不工作呢？所以，试着访问一个配置成需要使用代理服务器才能访问的网址吧。一个很好的例子就是规则列表本身的网址（<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">可以直接点这里</a>）。或者，也可以在图标的弹出菜单里切换到 GFWed （这样所有网址都会使用代理，相当于全局模式），然后再打开新标签页访问任意网站。</p>

<p>设置成功后，访问网页中如果有资源（如样式、图片、脚本等）未加载成功，则图标上会有提示。点菜单里未加载的资源即可，按提示操作，选择 GFWed ，让那些资源走代理一般就可以了。有时候这样操作一次还不够，因为新加载成功的资源又加载了别的资源，那重复个两三次大概也就行了。</p>

<p>P.S. 资源加载失败可能是多种原因导致，除了没有使用代理服务器以外，也可能是网络本身或者代理服务器不稳定、太慢，或者干脆是对方服务器的问题之类的。 SwitchyOmega 作为一个设置软件，很难判断具体是什么原因，只能向您报告问题而已。有时候即使用了代理也打不开，那也不是 SwitchyOmega 坏掉了。如果看见图标上有个数字觉得很烦很焦躁，可以到选项>通用>网络请求里关闭检测功能，但这只能隐藏问题而不能真正解决问题。</p>

<h3>gfwlist 规则列表地址更新</h3>

<p><a href="https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList.bak">这里提供的备份文件已经使用了新的地址</a>，新用户请放心使用。老用户也可下载新版备份文件覆盖（注意：会清空自定义的设置）。 如果想继续使用现在的设置，请注意在自动切换中，将规则列表网址手动改为新地址！ SwitchyOmega 不知道您在用 GFWList ，也不会自动更改列表的 URL 地址，所以只能请您手动改一下了。具体的要修改的位置在上面一张图上有标识，是深红色下划线标出的那个文本框（截图中仍然是旧地址，新地址见下方）。</p>

<p>新地址：</p>

<pre><code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt
</code></pre>

<p>旧地址(请不要再使用这个地址了，已经很久不更新了。):</p>

<p><del><a href="https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt">https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt</a></del></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GAE(Google App Engine)+goagent+chrome浏览器+SwitchyOmega图文教程]]></title>
    <link href="http://cooear.com/blog/2014/05/goagent-switchysharp-tu-wen-jiao-cheng/"/>
    <updated>2014-05-03T10:37:34+08:00</updated>
    <id>http://cooear.com/blog/2014/05/goagent-switchysharp-tu-wen-jiao-cheng</id>
    <content type="html"><![CDATA[<p>作为一个技术宅、IT男，同时为了满足我们的好奇心，求知欲，或不可告人的目的，我们常常需要看看“墙外”的风光。Windows下方便的有自由门、逍遥游等可以满足这个小小的要求，可会不定时的遭到“暗杀”，且网速慢、不稳定，用着十分的不爽。</p>

<p>现在推荐一个基于GAE（Google App Engine）+ goagent + switchysharp + chrome的翻墙之法，请不要害怕这过长的篇幅，设置的过程是相当的简单的，按部就班的来10分钟左右搞定。设置过程如下：</p>

<h3>一、简单介绍</h3>

<ol>
<li>GAE（Google App Engine）是一个开发、托管网络应用程序的平台；</li>
<li>goagent是一个使用Python和Google Appengine SDK编写的代理软件；</li>
<li>switch sharp是一个chrome插件，具体功能类似于Firefox的AutoProxy.</li>
</ol>


<h3>二、确保自己拥有一个Google账户</h3>

<p><strong>step1</strong>: 创建Google账号，并登录<a href="https://appengine.google.com/start/createapp">Google App Engine</a>按下图操作(已有账号的请跳过);</p>

<!--more-->


<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/1.png" title="创建Google Application ID" alt="创建Google Application ID" /></p>

<p><strong>step2</strong>: 创建自己的application</p>

<p>完成step1的验证操作后界面如下：</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/3.png" title="创建Google Application应用" alt="创建Google Application应用" /></p>

<p><strong>注</strong>：Application ID允许使用英文字母和短横线；填写完毕Application ID点击Check Available，检查是否可用</p>

<p>一切正常的话就会看到下面的界面（告诉你App已经申请成功了）</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/4.png" title="Google Application应用创建成功" alt="Google Application应用创建成功" /></p>

<p><br/>
<strong>注</strong>:每个Gmail账户最多只能创建10个Google App Engine应用，每个应用每天有1GB的免费流量。如果你经常下载或者观看视频建议多创建几个Google App Engine应用</p>

<h3>三、下载设置goagent</h3>

<p>step1: 下载<a href="https://github.com/phuslu/goagent/tags">goagent客户端</a></p>

<p>step2: 按图中“简单教程”中的步骤一步步来。</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/5.png" title="GoAgent简单教程" alt="GoAgent简单教程" /></p>

<p>step3: 修改local\proxy.ini中[gae]下的appid=你的appid(多个appid请用|隔开)，即前面创建的Application所设定的Application ID;</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/6.jpg" title="GoAgent的proxy.ini设置" alt="GoAgent的proxy.ini设置" /></p>

<p>step4: 打开server\uploader.bat,根据提示一次输入Application ID,邮箱地址和密码（如果设置了Gmail的两步验证请输入两步验证中生成的16位密码，即为独立应用单独生成的随机16位字符，而不是你的邮箱密码，<a href="http://cooear.com/blog/2013/07/gu-ge-zhang-hu-liang-bu-yan-zheng-she-zhi/">Gmail两步验证</a>在这里详细介绍）</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/7.jpg" title="GoAgent配置登录" alt="GoAgent配置登录" /></p>

<p><br/>
<strong>注</strong>: 使用GoAgent上网前，必须运行local\goagent.exe</p>

<h3>四、安装chrome浏览器的SwitchySharp插件</h3>

<p>安装chrome浏览器的<a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?hl=zh-CN">SwitchySharp插件</a>，具体过程在第三步的step2的简单教程中已经有过介绍。最新版Proxy SwitchyOmega<a href="https://github.com/FelisCatus/SwitchyOmega/releases/">下载地址</a>。</p>

<h3>五、设置switchsharp插件</h3>

<p><strong>注意</strong>：Proxy SwitchySharp升级为 <a href="http://pan.baidu.com/s/1i3rHHGT">Proxy SwitchyOmega</a> 主要设置和Proxy SwitchySharp相似，会在Proxy SwitchySharp设置后简单介绍。</p>

<p>step1: 按下图填写</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/8.jpg" title="chrome浏览器switchsharp设置" alt="chrome浏览器switchsharp设置" /></p>

<p>step2: 导入文件</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/9.png" title="chrome浏览器switchsharp配置文件导入" alt="chrome浏览器switchsharp配置文件导入" /></p>

<p>step3:选择“代理”或者“自动切换模式”</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/10.jpg" title="chrome浏览器switchsharp代理模式切换" alt="chrome浏览器switchsharp代理模式切换" /></p>

<p><br/>
<a href="http://pan.baidu.com/s/1i3rHHGT">Proxy SwitchyOmega</a>简介</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2015/03/unnamed1.png" title="Proxy SwitchyOmega升级下载" alt="Proxy SwitchyOmega升级下载" /></p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2015/03/unnamed2.png" title="Proxy SwitchyOmega升级下载" alt="Proxy SwitchyOmega升级下载" /></p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2015/03/unnamed3.png" title="Proxy SwitchyOmega升级下载" alt="Proxy SwitchyOmega升级下载" /></p>

<p><a href="http://cooear.com/blog/2014/05/switchyomega-configuration/">SwitchyOmega详细安装配置</a></p>

<h3>六、友情提示</h3>

<p>Google App Engine并非毫无限制，正如上文所说每个Gmail账号只能创建10个应用程序（最多10个AppID）。对于创建过的AppID，可以手动删除（72小时后生效，期间可以反悔）,AppID一旦删除，同名账号就不能再申请。</p>

<p>Google App Engine提供给每个AppID每天是1GB的流量，可以<a href="https://appengine.google.com/">登录</a>  点击你创建的AppID，可以查看你的流量图，以及每天免费配额还剩多少，如图：</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/11.jpg" title="Google Application应该流量图" alt="Google Application应该流量图" /></p>

<p><font color=red>注: 每天的流量重新清零的时间是北京时间16点整，而非0点。</font></p>

<p>至此大功告成，切接每次运行local\goagent.exe,打开chrome，你就可以畅游于互联网的任何角落</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/Over.jpg" title="云梯" alt="云梯" /></p>

<p><strong><font color=red>注意</font></strong>：<del>如果不想操作以上设置可以直接修改本机HOSTS文件达到相同效果，点击查看</del>;从个人使用情况再分享个Lantern翻墙，个人觉得Lantern的访问更稳定、速度更快。</p>

<p><br /></p>

<p><a href="http://cooear.com/blog/2014/08/lantern-deng-long-an-zhuang-he-shi-yong-jiao-cheng/">Lantern快速稳定翻墙教程地址</a></p>

<p><a href="http://cooear.com/blog/2016/05/xx-net-jie-li-goagent/">GoAgent完美接力工具</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux中find命令实例]]></title>
    <link href="http://cooear.com/blog/2014/04/linuxzhong-findming-ling-shi-li/"/>
    <updated>2014-04-25T00:01:24+08:00</updated>
    <id>http://cooear.com/blog/2014/04/linuxzhong-findming-ling-shi-li</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[12个非常有用的”df”命令查看Linux磁盘空间]]></title>
    <link href="http://cooear.com/blog/2014/02/12ge-fei-chang-you-yong-de-df-ming-ling-cha-kan-linuxci-pan-kong-jian/"/>
    <updated>2014-02-25T16:20:32+08:00</updated>
    <id>http://cooear.com/blog/2014/02/12ge-fei-chang-you-yong-de-df-ming-ling-cha-kan-linuxci-pan-kong-jian</id>
    <content type="html"><![CDATA[<p>　　你也许会在网上发现很用用于检查<strong>Linux</strong>磁盘空间的工具。然而，Linux拥有强大的内置磁盘空间检查工具"df"。"df"是"disk filesystem"的缩写，用于检查<strong>Linux</strong>系统上有效的可用磁盘空间。
　　
　　使用"-h"参数即(df -h)以对人友好的数据格式(kb,mb,GB)展示磁盘使用情况。这篇文章将用"df"命令全面的展示一种检查磁盘空间的方法。</p>

<ol>
<li><p>检查磁盘使用情况。</p>

<p> &ldquo;df"命令显示设备名称，总数据块，总磁盘空间，使用的磁盘空间，可用的磁盘空间和挂载的文件系统节点。</p>

<p> <!--more-->
     [root@belen ~]# df</p>

<pre><code> Filesystem           1K-blocks      Used Available Use% Mounted on
 /dev/cciss/c0d0p2     78361192  23185840  51130588  32% /
 /dev/cciss/c0d0p5     24797380  22273432   1243972  95% /home
 /dev/cciss/c0d0p3     29753588  25503792   2713984  91% /data
 /dev/cciss/c0d0p1       295561     21531    258770   8% /boot
 tmpfs                   257476         0    257476   0% /dev/shm
</code></pre></li>
<li><p>显示磁盘使用情况的所有信息。</p>

<p> 和上面类似，但它也显示了虚拟文件系统的信息以及所有文件系统的磁盘使用情况和内存利用率。</p>

<pre><code> [root@belen ~]# df -a

 Filesystem           1K-blocks      Used Available Use% Mounted on
 /dev/cciss/c0d0p2     78361192  23186116  51130312  32% /
 proc                         0         0         0   -  /proc
 sysfs                        0         0         0   -  /sys
 devpts                       0         0         0   -  /dev/pts
 /dev/cciss/c0d0p5     24797380  22273432   1243972  95% /home
 /dev/cciss/c0d0p3     29753588  25503792   2713984  91% /data
 /dev/cciss/c0d0p1       295561     21531    258770   8% /boot
 tmpfs                   257476         0    257476   0% /dev/shm
 none                         0         0         0   -  /proc/sys/fs/binfmt_misc
 sunrpc                       0         0         0   -  /var/lib/nfs/rpc_pipefs
</code></pre></li>
<li><p>以对人友好易都的格式显示磁盘使用情况。</p>

<p> 你是否注意到上面显示的数据信息不易都，因为我们习惯于使用mb，gb等格式读取和记忆数据大小信息。</p>

<p> &ldquo;df"命令使用&rdquo;-h"参数可用以对人友好和易都的格式显示磁盘使用情况（如: 1k 2M 3G）。</p>

<pre><code> [root@belen ~]# df -h

 Filesystem            Size  Used Avail Use% Mounted on
 /dev/cciss/c0d0p2      75G   23G   49G  32% /
 /dev/cciss/c0d0p5      24G   22G  1.2G  95% /home
 /dev/cciss/c0d0p3      29G   25G  2.6G  91% /data
 /dev/cciss/c0d0p1     289M   22M  253M   8% /boot
 tmpfs  
</code></pre></li>
<li><p>显示/home目录下的文件系统信息</p>

<pre><code> [root@belen ~]# df -hT /home

 Filesystem      Type    Size  Used Avail Use% Mounted on
 /dev/cciss/c0d0p5   ext3     24G   22G  1.2G  95% /home
</code></pre></li>
<li><p>以字节(Bytes)的形式展示文件系统信息。</p>

<pre><code> [root@belen ~]# df -k

 Filesystem           1K-blocks      Used Available Use% Mounted on
 /dev/cciss/c0d0p2     78361192  23187212  51129216  32% /
 /dev/cciss/c0d0p5     24797380  22273432   1243972  95% /home
 /dev/cciss/c0d0p3     29753588  25503792   2713984  91% /data
 /dev/cciss/c0d0p1       295561     21531    258770   8% /boot
 tmpfs                   257476         0    257476   0% /dev/shm
</code></pre></li>
<li><p>以MB的形式展示文件系统信息。</p>

<pre><code> [root@belen ~]# df -m

 Filesystem           1M-blocks      Used Available Use% Mounted on
 /dev/cciss/c0d0p2        76525     22644     49931  32% /
 /dev/cciss/c0d0p5        24217     21752      1215  95% /home
 /dev/cciss/c0d0p3        29057     24907      2651  91% /data
 /dev/cciss/c0d0p1          289        22       253   8% /boot
 tmpfs                      252         0       252   0% /dev/shm
</code></pre></li>
<li><p>以GB的形式展示文件系统信息。</p>

<pre><code> [root@belen ~]# df -h

 Filesystem            Size  Used Avail Use% Mounted on
 /dev/cciss/c0d0p2      75G   23G   49G  32% /
 /dev/cciss/c0d0p5      24G   22G  1.2G  95% /home
 /dev/cciss/c0d0p3      29G   25G  2.6G  91% /data
 /dev/cciss/c0d0p1     289M   22M  253M   8% /boot
 tmpfs                 252M     0  252M   0% /dev/shm
</code></pre></li>
<li><p>展示文件系统索引节点。</p>

<p> &ldquo;df"使用&rdquo;-i"参数显示文件系统已经使用的索引信息和百分比。</p>

<pre><code> root@tecmint ~]# df -i

 Filesystem            Inodes   IUsed   IFree IUse% Mounted on
 /dev/cciss/c0d0p2    20230848  133143 20097705    1% /
 /dev/cciss/c0d0p5    6403712  798613 5605099   13% /home
 /dev/cciss/c0d0p3    7685440 1388241 6297199   19% /data
 /dev/cciss/c0d0p1      76304      40   76264    1% /boot
 tmpfs                  64369       1   64368    1% /dev/shm
</code></pre></li>
<li><p>展示文件类型。</p>

<pre><code> [root@belen ~]# df -T

 Filesystem      Type   1K-blocks  Used      Available Use% Mounted on
 /dev/cciss/c0d0p2   ext3    78361192  23188812  51127616  32%   /
 /dev/cciss/c0d0p5   ext3    24797380  22273432  1243972   95%   /home
 /dev/cciss/c0d0p3   ext3    29753588  25503792  2713984   91%   /data
 /dev/cciss/c0d0p1   ext3    295561     21531    258770    8%    /boot
 tmpfs           tmpfs   257476         0    257476    0%   /dev/shm
</code></pre>

<p> 从上面的输出你可以看到并没有文件类型的信息，当你使用"-T"可以查看相关的文件类型。</p></li>
<li><p>展示特定的文件类型。</p>

<p>如果你想只显示特定的文件类型可以使用"-t"参数。例如：</p>

<pre><code>[root@belen ~]# df -t ext3

Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/cciss/c0d0p2     78361192  23190072  51126356  32% /
/dev/cciss/c0d0p5     24797380  22273432   1243972  95% /home
/dev/cciss/c0d0p3     29753588  25503792   2713984  91% /data
/dev/cciss/c0d0p1       295561     21531    258770   8% /boot
</code></pre></li>
<li><p>展示排除特定的文件类型。</p>

<pre><code>[root@belen ~]# df -x ext3

Filesystem           1K-blocks      Used Available Use% Mounted on
tmpfs                   257476         0    257476   0% /dev/shm
</code></pre></li>
<li><p>&ldquo;df"命令的帮助信息。</p>

<pre><code>[root@belen ~]# df --help

Usage: df [OPTION]... [FILE]...
Show information about the file system on which each FILE resides,
or all file systems by default.

Mandatory arguments to long options are mandatory for short options too.
-a, --all             include dummy file systems
-B, --block-size=SIZE use SIZE-byte blocks
-h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)
-H, --si              likewise, but use powers of 1000 not 1024
-i, --inodes          list inode information instead of block usage
-k                    like --block-size=1K
-l, --local           limit listing to local file systems
--no-sync         do not invoke sync before getting usage info (default)
-P, --portability     use the POSIX output format
--sync            invoke sync before getting usage info
-t, --type=TYPE       limit listing to file systems of type TYPE
-T, --print-type      print file system type
-x, --exclude-type=TYPE   limit listing to file systems not of type TYPE
-v                    (ignored)
--help     display this help and exit
--version  output version information and exit

SIZE may be (or may be an integer optionally followed by) one of following:
kB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.

Report bugs to .
</code></pre>

<p>　　</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Iphone4/4S换电池教程]]></title>
    <link href="http://cooear.com/blog/2013/12/iphone-huan-dian-chi-jiao-cheng/"/>
    <updated>2013-12-03T20:10:47+08:00</updated>
    <id>http://cooear.com/blog/2013/12/iphone-huan-dian-chi-jiao-cheng</id>
    <content type="html"><![CDATA[<p>苹果手机一向以不能换电池著称，但是电池用久了待机时间会越来愈短，一般这种情况出现在使用一年以后的手机上，而官方更换的价格又太贵，淘宝买块电池跟着iPhone中文网编辑一起动手自己换，实惠又方便。现在写教程如下：</p>

<p>换Iphone4/4S电池工具：Iphone4/4S、Iphone专用螺丝刀（淘宝购买）、电池（淘宝有各种类型）、撬棍……</p>

<!--more-->


<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/2012040408445599534.jpg" title="Iphone换电池教程准备工作" alt="Iphone换电池教程准备工作" /></p>

<h3>1、打开Iphone尾部螺丝（根据尾部螺丝外形选择合适的螺丝刀）。</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/2.jpg" title="Iphone换电池教程打开后盖" alt="Iphone换电池教程打开后盖" /></p>

<h3>2、线上推后盖，打开后盖。</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/3.jpg" title="Iphone换电池教程打开后盖" alt="Iphone换电池教程打开后盖" /></p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/4.jpg" title="Iphone换电池教程打开后盖" alt="Iphone换电池教程打开后盖" /></p>

<h3>3、拧开电池连接处的螺丝，用撬棍撬起电池连接处。</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/5.jpg" title="Iphone换电池教程去掉电池" alt="Iphone换电池教程去掉电池" /></p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/6.jpg" title="Iphone换电池教程取下电池" alt="Iphone换电池教程取下电池" /></p>

<h3>4、拉动压在电池上的塑料条，拆下电池。</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/7.jpg" title="Iphone换电池教程取下电池" alt="Iphone换电池教程取下电池" /></p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/8.jpg" title="Iphone换电池教程彻底取下电池" alt="Iphone换电池教程彻底取下电池" /></p>

<h3>5、装电池，弯一下电池连接处的形成一个褶皱。</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/9.jpg" title="Iphone换电池教程装上新的电池" alt="Iphone换电池教程装上新的电池" /></p>

<h3>6、对齐电池连接处，有一个活动的零件需要和螺丝孔对齐，并压在电池连接处下面。</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/10.jpg" title="Iphone换电池教程新电池准备" alt="Iphone换电池教程新电池准备" /></p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/11.jpg" title="Iphone换电池教程装入新电池" alt="Iphone换电池教程装入新电池" /></p>

<h3>7、拧紧电池连接处，当听到清脆的“咔”一声，拧上螺丝。</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/12.jpg" title="Iphone换电池教程安装新电池" alt="Iphone换电池教程安装新电池" /></p>

<h3>8、完成</h3>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/12/13.jpg" title="Iphone换电池教程完成" alt="Iphone换电池教程完成" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux踢出在线用户]]></title>
    <link href="http://cooear.com/blog/2013/08/linuxti-chu-zai-xian-yong-hu/"/>
    <updated>2013-08-30T14:37:46+08:00</updated>
    <id>http://cooear.com/blog/2013/08/linuxti-chu-zai-xian-yong-hu</id>
    <content type="html"><![CDATA[<h3>linux踢出远程登录用户命令：</h3>

<p>查看当前自己的终端：</p>

<pre><code>[root@belen ~]# who am i
root     pts/1        2013-01-22 10:45 (192.168.250.110)
</code></pre>

<p><strong>一、</strong> 输入w命令查看已登录用户信息
    <!--more--></p>

<pre><code>[root@belen ~]# who
root     pts/0        2013-01-22 09:56 (192.168.250.27)
root     pts/1        2013-01-22 10:45 (192.168.250.110)
[root@belen ~]# w
10:46:13 up 4 days, 16:28,  2 users,  load average: 0.36, 0.38, 0.29
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.250.27   09:56   12:03   0.02s  0.02s -bash
root     pts/1    192.168.250.110  10:45    0.00s  0.02s  0.01s w   
</code></pre>

<p><strong>二、</strong> 踢出用户:pkill -kill -t 用户tty</p>

<pre><code>[root@belen ~]# pkill -kill -t pts/0
</code></pre>

<p><strong>三、</strong> 验证操作是否成功</p>

<pre><code>[root@belen ~]# w
10:48:17 up 4 days, 16:30,  1 user,  load average: 0.32, 0.35, 0.28
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/1    192.168.250.110  10:45    0.00s  0.03s  0.02s w
</code></pre>

<p><br /><br /><br /></p>

<hr />

<p><strong>w命令的属性解释</strong>：</p>

<hr />

<ul>
<li>USER：显示登陆用户帐号名。用户重复登陆，该帐号也会重复出现。</li>
<li>TTY：用户登陆所用的终端。</li>
<li>FROM：显示用户在何处登陆系统。</li>
<li>LOGIN@：是LOGIN AT的意思，表示登陆进入系统的时间。</li>
<li>IDLE：用户空闲时间，从用户上一次任务结束后，开会记时。</li>
<li>JCPU：一终端代号来区分，表示在摸段时间内，所有与该终端相关的进程任务所耗费的CPU时间。</li>
<li>PCPU：指WHAT域的任务执行后耗费的CPU时间。</li>
<li>WHAT：表示当前执行的任务</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux日志系统浅析]]></title>
    <link href="http://cooear.com/blog/2013/08/linuxri-zhi-xi-tong-qian-xi/"/>
    <updated>2013-08-23T15:47:25+08:00</updated>
    <id>http://cooear.com/blog/2013/08/linuxri-zhi-xi-tong-qian-xi</id>
    <content type="html"><![CDATA[<p>　　当我们使用的Linux系统正常运行时，花费一些时间去学习和了解Linux的日志系统/var/log 还是很有必要的;因为当你了解路Linux的日志系统时当服务器或者某项服务运行不正常时可以很方便的通过日志定位问题所在,所以正确的设置Linux的日志输出可以达到事半功倍的效果。通常情况下你可以使用less、more、cat、vi、grep或者tail命令来查看log文件的内容。</p>

<p>定义：</p>

<p>　　<strong>log files:UNIX/LINUX</strong>有一个严格的政策不报告错误消息到用户界面即使可能没有用户在阅读这些消息。而错误消息的交互命令发送到终端屏幕、错误或信息消息产生的非交互式命令是“记录”的文件在目录<strong>/var/log/</strong>;日志文件在<strong>/var/log</strong>通常可以无限增长,可能需要定期清洗。
　　</p>

<!--more-->


<ul>
<li>/var/log/auth.log</li>
</ul>


<p>　　记录所有正常用户和系统进程的所有登录、登出.</p>

<ul>
<li>/var/log/btmp</li>
</ul>


<p>　　记录错误的登录尝试，执行lastb命令可以查看到最后一个不成功的登录尝试.</p>

<ul>
<li>/var/log/debug</li>
</ul>


<p>　　Debugging output from various packages.</p>

<ul>
<li>/var/log/dmesg</li>
</ul>


<p>　　内核环缓冲区,此文件的内容是指由dmesg命令。</p>

<ul>
<li>/var/log/gdm/</li>
</ul>


<p>　　GDM log files. Normally a subset of the last X log file. See /var/log/xdm.log for mode details.</p>

<ul>
<li>/var/log/wtmp</li>
</ul>


<p>　　该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件。因此随着系统正常 运行时间的增加，该文件的大小也会越来越大，增加的速度取决于系统用户登录的次数。该日志文件可以用来查看用户的登录记录，last命令就通过访问这个文 件获得这些信息，并以反序从后向前显示用户的登录记录，last也能根据用户、终端 tty或时间显示相应的记录。</p>

<ul>
<li>/var/log/xferlog</li>
</ul>


<p>　　该日志文件记录FTP会话，可以显示出用户向FTP服务器或从服务器拷贝文件的记录。该文件会显示用户拷贝到服务器上的用来入侵服务器的恶意程序，以及该用户拷贝了哪些文件供他使用。</p>

<ul>
<li>/var/log/boot.log</li>
</ul>


<p>　　该文件记录系统在引导过程中发生的事件，就是Linux系统开机自检过程显示的信息。</p>

<ul>
<li>/var/log/cron</li>
</ul>


<p>　　该日志文件记录crontab守护进程crond所派生的子进程的动作，无论crontab(或crond)开始执行一个job该日志都将记录.</p>

<ul>
<li>/var/log/maillog</li>
</ul>


<p>　　该日志文件记录服务器上mail服务的所有活动(邮件的发出和接收);它可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统.</p>

<ul>
<li>/etc/rsyslog.conf</li>
</ul>


<p>　　controls what goes inside some of the log files. For example, following is the entry in rsyslog.conf for /var/log/messages.</p>

<pre><code>$ grep "/var/log/messages"                  /etc/rsyslog.conf
*.info;mail.none;authpriv.none;cron.none      /var/log/messages　　
</code></pre>

<p>　　</p>

<ul>
<li>/var/log/lastlog</li>
</ul>


<p>　　记录最近成功登录的事件和最后一次不成功的登录事件,该文件是二进制文件，需要使用 lastlog命令查看.</p>

<ul>
<li>/var/log/syslog</li>
</ul>


<p>　　The &lsquo;system&rsquo; log file. The contents of this file is managed via the syslogd daemon which more often than not takes care of all log manipulation on most systems.</p>

<ul>
<li>/var/log/xdm.log</li>
</ul>


<p>　　XDM log file. Normally subset of the last X startup log and pretty much useless in light of the details the X logs is able to provide us with. Only consult this file if you have XDM specific issues otherwise just use the X logfile.</p>

<ul>
<li>/var/log/secure：</li>
</ul>


<p>　　记录登入系统存取资料的日志，例如 pop3, ssh, telnet, ftp 等都都会记录在次日志文件中。
　　</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下scp语法命令具体实例总结]]></title>
    <link href="http://cooear.com/blog/2013/08/linuxxia-scpyu-fa-ming-ling-ju-ti-shi-li-zong-jie/"/>
    <updated>2013-08-03T15:13:58+08:00</updated>
    <id>http://cooear.com/blog/2013/08/linuxxia-scpyu-fa-ming-ling-ju-ti-shi-li-zong-jie</id>
    <content type="html"><![CDATA[<p>　　<strong>scp</strong>就是secure copy可以简单的理解为是利用SSH协议来传输数据的cp命令，使用和ssh相同的认证方式，提供相同的安全保证 。但是两者的区别在于cp命令是在同一台物理主机上使用的，而scp则可以在两台不同的物理主机上传输文件数据。</p>

<p><strong>SCP</strong>命令语法:</p>

<pre><code>scp [-1245BCpqrv] [-c cipher] [F ssh_config] [-I identity_file] [-l limit] [-o ssh_option] [-P port] [-S program] [[user@]host1:] file1 […] [[suer@]host2:]file2
</code></pre>

<p>scp可选参数：</p>

<!--more-->


<table>
<thead>
<tr>
<th style="text-align:center;">相关参数</th>
<th style="text-align:center;">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">-v</td>
<td style="text-align:center;">和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 .</td>
</tr>
<tr>
<td style="text-align:center;">-C</td>
<td style="text-align:center;">使能压缩选项</td>
</tr>
<tr>
<td style="text-align:center;">-P</td>
<td style="text-align:center;"> 选择端口 . 注意 -p 已经被 rcp 使用 .</td>
</tr>
<tr>
<td style="text-align:center;">-4</td>
<td style="text-align:center;"> 强行使用 IPV4 地址 . </td>
</tr>
<tr>
<td style="text-align:center;">-6</td>
<td style="text-align:center;">强行使用 IPV6 地址 .</td>
</tr>
</tbody>
</table>


<p>scp是linux下的远程拷贝</p>

<p>命令：</p>

<ol>
<li><p>将本地文件拷贝到远程：scp  文件名 用户名@计算机IP或者计算机名称:远程路径</p>

<pre><code> scp local_file remote_username@remote_ip:remote_folder
</code></pre></li>
<li><p>从远程将文件拷回本地：scp  用户名@计算机IP或者计算机名称:文件名 本地路径</p>

<pre><code> scp remote_username@remote_ip:remote_folder local_file
</code></pre></li>
<li><p>将本地目录拷贝到远程：scp -r 目录名   用户名@计算机IP或者计算机名称:远程路径</p>

<pre><code> scp -r local_folder remote_username@remote_ip:remote_dir
</code></pre></li>
<li><p>从远程将目录拷回本地：scp -r   用户名@计算机IP或者计算机名称:目录名本地路径</p>

<pre><code> scp -r remote_username@remote_ip:remote_folder local_dir
</code></pre></li>
</ol>


<p>　　另外，作为网站管理员会经常涉及两天计算机间的文件传输，如：数据文件的异地备份，但作为脚本又不可能自己输入scp的用户密码，故总结了一下两张方法：</p>

<ul>
<li><p>方法一:</p>

<pre><code>  sshpass -p 'password' scp file.gz root@xxx.xxx.xxx.1:/backup
</code></pre></li>
<li><p>方法二:</p>

<pre><code>  #!/usr/bin/expect
  spawn scp  backup.sql.gz root@remote_ip:remote_folder
  set pass "password"
  expect {
      password: {send "$pass\r"; exp_continue}
  }   
</code></pre></li>
<li><p>执行这个脚本</p>

<pre><code>  expect send_file.exp
</code></pre></li>
</ul>


<p><br /><br /></p>

<hr />

<p><strong>注</strong>:网上还普遍有一种方法“建立两台计算机之间的安全信任关系”这样在脚本执行scp时也可不输入密码，但cooear不太喜欢这种方法所有没有介绍，需要的可以自行Google。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谷歌账户两步验证设置]]></title>
    <link href="http://cooear.com/blog/2013/07/gu-ge-zhang-hu-liang-bu-yan-zheng-she-zhi/"/>
    <updated>2013-07-03T11:27:45+08:00</updated>
    <id>http://cooear.com/blog/2013/07/gu-ge-zhang-hu-liang-bu-yan-zheng-she-zhi</id>
    <content type="html"><![CDATA[<p>随着计算机技术和网络技术的发展，网络安全问题，在今天已经成为网络世界里最为人关注的问题之一。作为我等P民其实所担心的网络安全方面的无非就是自己的QQ、MSN、Dropbox、邮箱、银行卡的账号密码和自己的个人信息不被恶意的盗用，自己的电脑不被恶意挂马等等。其实现在很多账号都已经增加了两步验证（手机短信验证）现在对Gmail的两步验证设置做个简单介绍：</p>

<h3>一、进入<a href="https://www.google.com/settings">谷歌账户设置</a>页面,在安全性-两步验证出，点击修改；</h3>

<p>1）、点击安全（security）-修改（edit）</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/google%E8%B4%A6%E6%88%B7%E8%AE%BE%E7%BD%AE.jpg" title="google账户设置" alt="google账户设置" /></p>

<!--more-->


<h3>二、手机验证（开始设置->填写手机号码->填写收到的短信验证码）；</h3>

<p>2）、开始设置google两步验证</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/google%E8%B4%A6%E5%8F%B7%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E8%AE%BE%E7%BD%AE.jpg" title="google账号手机验证设置" alt="google账号手机验证设置" /></p>

<p>3）、填写手机号码</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/google%E8%B4%A6%E6%88%B7%E8%AE%BE%E7%BD%AE%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E9%AA%8C%E8%AF%81.jpg" title="google账户设置手机号码验证" alt="google账户设置手机号码验证" /></p>

<p>4）、填写收到的google验证码</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/google%E8%B4%A6%E6%88%B7%E8%AE%BE%E7%BD%AE%E9%AA%8C%E8%AF%81%E7%A0%81.jpg" title="google账户设置验证码" alt="google账户设置验证码" /></p>

<p>完成谷歌账户两步验证设置</p>

<h3>三、创建和生成密码</h3>

<p>当Google两步验证开启后使用Google应用或者服务时需要使用单独的应用密码</p>

<p>5）、创建Google应该密码</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/%E5%88%9B%E5%BB%BA%E5%92%8C%E7%94%9F%E6%88%90%E5%AF%86%E7%A0%81.jpg" title="创建和生成密码" alt="创建和生成密码" /></p>

<p>6）、填写名称，生成密码</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/%E7%94%9F%E6%88%90%E5%AF%86%E7%A0%81.jpg" title="生成密码" alt="生成密码" /></p>

<p>7）、应用专用密码（记下黄色背景上的密码）</p>

<p><img src="http://g1c1i0.cooear.com/images/uploads/2013/07/%E5%BA%94%E7%94%A8%E5%AF%86%E7%A0%81.jpg" title="应用密码" alt="应用密码" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优秀的程序员不会为股权卖命]]></title>
    <link href="http://cooear.com/blog/2013/04/you-xiu-de-cheng-xu-yuan-bu-hui-wei-gu-quan-mai-ming/"/>
    <updated>2013-04-27T11:26:22+08:00</updated>
    <id>http://cooear.com/blog/2013/04/you-xiu-de-cheng-xu-yuan-bu-hui-wei-gu-quan-mai-ming</id>
    <content type="html"><![CDATA[<p>编者按：本文作者 Yegor Bugayenko 。作者质疑企业家筹不到启动资金，即通常意义上的现金流。一个企业家可能知道怎么为自己的项目做财务规划，但不一定懂得怎么从项目运作中产生并维持现金流。股权只能作为锦上添花，现金加股权的报酬才能受到程序员的青睐。</p>

<p>“你是个优秀的程序员，我是个伟大的企业家，我这有个极具创意的想法，你帮我实现出来。我手头没钱给你，但作为回报，我可以给你股权。怎么样？” 每个月都有人这样问我，通常我都是拒绝的，不是因为我不喜欢那些产品创意，其实那些创意点听起来很有意思。也不是因为我太忙没时间，为了好的创意，再忙也会挤出时间去做。我拒绝，是因为我根本不认可你是个伟大的企业家。</p>

<!--more-->


<p>你希望有一个或者一群优秀的程序员来帮你实现你的产品，并愿意以股权作为回报。这场交易听起来是合理的。</p>

<p>但是，作为企业家，你在这场交易中能做些什么？</p>

<p>你有多少 “真枪实弹” 可以贡献？</p>

<p>你说你是个伟大的企业家，对吗？那你怎么可能没钱？怎么会找不到人来为辛勤工作的程序员支付报酬呢？</p>

<p>我可以帮你实现你的产品创意，但你可能还是会无果而终。其实你已经算失败了，因为你都找不到初始投资来支撑你产品的起步。你凭什么认为产品实现后，就一定会成功呢？</p>

<p>我想说的是，优秀的程序员永远不会为了股权去卖命。不是因为程序员执着于眼前的贪婪，也不是因为他们不想冒风险，更不是因为他们不相信这是个好的创意。都不是。</p>

<p>一个优秀的程序员愿意为一个伟大的企业家卖命，伟大的企业家也一定知道怎么去筹钱。那才是个像样的企业家。</p>

<p>注：本文译者翠西牛。</p>

<p>本文编译自：yegor256.com，如若转载，请注明出处：<a href="http://36kr.com/p/5042581.html">http://36kr.com/p/5042581.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux中10个有用的链接操作示例]]></title>
    <link href="http://cooear.com/blog/2013/02/linuxzhong-10ge-you-yong-de-lian-jie-cao-zuo-shi-li/"/>
    <updated>2013-02-20T00:01:08+08:00</updated>
    <id>http://cooear.com/blog/2013/02/linuxzhong-10ge-you-yong-de-lian-jie-cao-zuo-shi-li</id>
    <content type="html"><![CDATA[<p>Linux中的链接命令意味着几个命令联合在一起使用，他们在执行命令时依据彼此之间执行的结果。Linux中的链接命令就像你使用shell语言写的能在命令行中直接执行的shell脚本。链接命令是程序的自动化成为可能。此外，在链接命令的作用下一台无人操作的机器可以有序的运行多个系统。</p>

<p>本文旨在对常用的链接命(command­-chaining)令通过简要分析描述和相应的例子来提高我们码代码的能力，使我们能够写出更精炼更高效的代码从而降低系统负载。</p>

<!--more-->


<ol>
<li><p><strong>&amp;符号</strong></p>

<p> <strong>‘&amp;’</strong>符号作用是使命令可以后台运行而不中断执行。在命令行终端中键入下面命令并以空格和<strong>&lsquo;&amp;&rsquo;</strong>符号隔开。另外，你可以一行执行多个后台命令。</p>

<p> 后台执行1条命令如下：</p>

<pre><code> belen@localhost:~$ ping -c3 www.cooear.com &amp;
</code></pre>

<p> 后台同时执行2条命令如下：</p>

<pre><code> root@localhost:/home/belen# apt-get update &amp; apt-get upgrade &amp;
</code></pre></li>
<li><p><strong>分号命令(;)</strong></p>

<p> 分号命令是为了使在一行中执行的多个命令可以有序的单独执行。</p>

<pre><code> root@localhost:/home/belen# apt-get update ; apt-get upgrade ; mkdir test
</code></pre>

<p> 上面一块执行的命令中地一个执行<strong>update</strong>命令，然后执行<strong>upgrade</strong>命令最后执行在当前目录下创建‘test’目录的命令。</p></li>
<li><p><strong>&amp;&amp;符号命令</strong></p>

<p> <strong>&amp;&amp;</strong>命令只有在地一个命令执行成功后才会执行第二个命令，即只有第一个命令的退出状态为1时。这个命令对于检查最后一个命令的执行状态非常有用。</p>

<p> 例如，我想访问网站 <strong>cooear.com</strong>于是使用命令行访问，在访问前我需要先检查下网站所在主机是否可以正常访问。</p>

<pre><code> root@localhost:/home/belen# ping -c3 www.cooear.com &amp;&amp; links www.cooear.com
</code></pre></li>
<li><p><strong>||符号命令</strong></p>

<p> 或命令(<strong>OR Operator</strong>)和程序中的‘<strong>else</strong>’类似。上面的命令告诉我们只有在第一个命令正确执行后才能执行第二个命令，即第一个命令的退出状态值为‘1’。</p>

<p> 例如，当我们想使用非root用户执行'apt-get update'，当第一个命令执行失败再执行第二个名'links www.cooear.com'时可以使用下面的代码。</p>

<pre><code> belen@localhost:~$ apt-get update || links cooear.com
</code></pre>

<p> 上面的命令因为当前用户不能执行系统的<strong>update</strong>操作，所以第一个命令执行失败因此最后一个命令'<strong>links cooear.com</strong>&lsquo;被执行</p>

<pre><code> belen@localhost:~$ mkdir test || links cooear.com   
</code></pre></li>
<li><p><strong>!符号命令</strong></p>

<p> <strong>!</strong>符合命令(<strong>NOT Operator</strong>)和程序中的'<strong>except</strong>&lsquo;类似。这个命令将执行所有除了提供的条件。为了更好的理解我们将在你的home目录创建目录'belen'然后‘<strong>cd</strong>’到该目录。</p>

<pre><code> belen@localhost:~$ mkdir belen 
 belen@localhost:~$ cd belen
</code></pre>

<p> 接下来在'belen'目录中创建各种类型的文件。</p>

<pre><code> belen@localhost:~/belen$ touch a.doc b.doc a.pdf b.pdf a.xml b.xml a.html b.html
</code></pre>

<p> 我们已经在'belen'目录中创建了各种文件。</p>

<pre><code> belen@localhost:~/belen$ ls 
 a.doc  a.html  a.pdf  a.xml  b.doc  b.html  b.pdf  b.xml        
</code></pre>

<p> 现在使用一种简单的方法删除除'html'结尾的所有文件。</p>

<pre><code> belen@localhost:~/belen$ rm -r !(*.html)
</code></pre>

<p> 最后为了验证结果，在命令行中执行ls 命令列出所有的文件列表。</p>

<pre><code> belen@localhost:~/belen$ ls 
 a.html  b.html      
</code></pre></li>
<li><p><strong>AND-OR 符号命令(&amp;&amp; – ||)</strong></p>

<p> 当前符号命令(<strong>AND-OR operator</strong>)是使用'AND'(<strong>&amp;&amp;</strong>)和'OR'(<strong>||</strong>)结合的命令，这个命令和if-else类似。</p>

<p> 例如，我们执行ping <strong>cooear.com</strong>，如果成功则输出'<strong>Verified</strong>&lsquo;否则输出'Host Down'。</p>

<pre><code> belen@localhost:~/belen$ ping -c3 www.cooear.com &amp;&amp; echo "Verified" || echo "Host Down"
</code></pre>

<p> 代码输出：</p>

<pre><code> PING www.cooear.com (220.181.136.225) 56(84) bytes of data. 
 64 bytes from www.cooear.com (220.181.136.225): icmp_req=1 ttl=55 time=216 ms 
 64 bytes from www.cooear.com (220.181.136.225): icmp_req=2 ttl=55 time=224 ms 
 64 bytes from www.cooear.com (220.181.136.225): icmp_req=3 ttl=55 time=226 ms 

 --- www.cooear.com ping statistics --- 
 3 packets transmitted, 3 received, 0% packet loss, time 2001ms 
 rtt min/avg/max/mdev = 216.960/222.789/226.423/4.199 ms 
 Verified    
</code></pre>

<p> 现在断开你的网络连接执行同样的命令试试。</p>

<pre><code> belen@localhost:~/belen$ ping -c3 www.cooear.com &amp;&amp; echo "verified" || echo "Host Down"
</code></pre>

<p> 代码输出：</p>

<pre><code> ping: unknown host www.tecmint.com 
 Host Down           
</code></pre></li>
<li><p><strong>管道符号命令(|)</strong></p>

<p> 当我们想将上一个输出的命令作为下一个命令的输入值时那么管道命令(|)将是十分有用的。例如，将'<strong>ls -l</strong>&lsquo;输出的值通过管道命令传给<strong>less</strong>命令。</p>

<pre><code> belen@localhost:~$ ls -l | less
</code></pre></li>
<li><p><strong>组合符号命令{}</strong></p>

<p> 两个或者更多的命令联合执行，第二个命令的执行依据第一个命令的执行结果。</p>

<p> 例如，检查我的'Downloads'目录下是否存在文件'xyz.txt'和'xyz1.txt'，并输出相应的结果。</p>

<pre><code> belen@localhost:~$ [ -f /home/belen/Downloads/xyz.txt ] || echo "The file does not exist"
 belen@localhost:~$ [ -f /home/belen/Downloads/xyz1.txt ] || echo "The file does not exist" 
 "The file does not exist"
</code></pre></li>
<li><p><strong>优先执行符号命令()</strong></p>

<p> 这个符号()允许命令按照一定的优先级执行。</p>

<pre><code> Command_x1 &amp;&amp; Command_x2 || Command_x3 &amp;&amp; Command_x4.
</code></pre>

<p> 上面的命令如果<strong>Command_x1</strong>执行失败会怎样？<strong>Command_x2</strong>,<strong>Command_x3</strong>,<strong>Command_x4</strong>这个几个命令一个也不会执行，因此我们应该使用优先执行符号：</p>

<pre><code> (Command_x1 &amp;&amp; Command_x2) || (Command_x3 &amp;&amp; Command_x4)
</code></pre>

<p> 上面这个命令即使<strong>Command_x1</strong>和<strong>Command_x2</strong>都执行失败，<strong>Command_x3</strong>和<strong>Command_x4</strong>也会根据<strong>Command_x3</strong>的退出状态执行</p></li>
<li><p><strong>Concatenation Operator ()</strong></p>

<p>The Concatenation Operator () as the name specifies, is used to concatenate large commands over several lines in the shell. For example, The below command will open text file test(1).txt.</p>

<pre><code>belen@localhost:~/Downloads$ nano test\(1\).txt
</code></pre></li>
</ol>

]]></content>
  </entry>
  
</feed>
